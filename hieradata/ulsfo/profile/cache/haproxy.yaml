profile::cache::haproxy::varnish_socket:
    - prefix: unix
      address: /run/varnish-frontend-0.socket
      maxconn: 20000

profile::cache::haproxy::post_acl_actions:
  # To disable concurrency enforcement, comment out this entire block below.
  http:
    - context: http-request
      verb: silent-drop
      condition: if too_much_recent_concurrency || too_many_concurrent_queries mark_as_too_much_concurrency
      comment: "To disable concurrency enforcement, see post_acl_actions in puppet/hieradata/common/profile/cache/haproxy.yaml"

profile::cache::haproxy::sticktables:
  - name: httpreqrate_http
    type: ipv6
    size: 1m
    expire: 300s
    store:
      - 'http_req_rate(10s)'
      - 'gpc0_rate(300s)'

profile::cache::haproxy::pre_acl_actions:
  http:
    - context: http-request
      verb: track-sc0 src table httpreqrate_http

profile::cache::haproxy::vars:
  http:
    - direction: request
      name: 'req.dummy_silent_drop_port80'  # exists only for logging purposes
      value: 'src,debug(silent-drop_port80_for_300s,stderr)'
      # only log the first time an IP violates too_many_concurrent_queries and starts being silent-dropped
      acl: 'too_many_concurrent_queries !too_much_recent_concurrency'

profile::cache::haproxy::acls:
  http:
    - name: 'too_many_concurrent_queries'
      criterion: 'sc0_trackers(httpreqrate_http)'
      operator: 'ge'
      value: '400'
    - name: 'too_much_recent_concurrency'
      # Add hysteresis.
      criterion: 'sc0_gpc0_rate(httpreqrate_http)'
      operator: 'gt'
      value: '0'
    - name: 'mark_as_too_much_concurrency'
      criterion: 'sc0_inc_gpc0(httpreqrate_http)'  # increments the gpc1 counter
      # (so yes, evaluating this ACL is mutating, and yes, this is haproxy-idiomatic)
      operator: 'gt'
      value: '0'

